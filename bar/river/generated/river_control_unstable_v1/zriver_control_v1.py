# This file has been autogenerated by the pywayland scanner

# Copyright 2020 The River Developers
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from __future__ import annotations

from pywayland.protocol_core import (
    Argument,
    ArgumentType,
    Global,
    Interface,
    Proxy,
    Resource,
)

from pywayland.protocol.wayland import WlSeat
from .zriver_command_callback_v1 import ZriverCommandCallbackV1


class ZriverControlV1(Interface):
    """Run compositor commands

    This interface allows clients to run compositor commands and receive a
    success/failure response with output or a failure message respectively.

    Each command is built up in a series of add_argument requests and executed
    with a run_command request. The first argument is the command to be run.

    A complete list of commands should be made available in the man page of the
    compositor.
    """

    name = "zriver_control_v1"
    version = 1


class ZriverControlV1Proxy(Proxy[ZriverControlV1]):
    interface = ZriverControlV1

    @ZriverControlV1.request()
    def destroy(self) -> None:
        """Destroy the river_control object

        This request indicates that the client will not use the river_control
        object any more. Objects that have been created through this instance
        are not affected.
        """
        self._marshal(0)
        self._destroy()

    @ZriverControlV1.request(
        Argument(ArgumentType.String),
    )
    def add_argument(self, argument: str) -> None:
        """Add an argument to the current command

        Arguments are stored by the server in the order they were sent until
        the run_command request is made.

        :param argument:
            the argument to add
        :type argument:
            `ArgumentType.String`
        """
        self._marshal(1, argument)

    @ZriverControlV1.request(
        Argument(ArgumentType.Object, interface=WlSeat),
        Argument(ArgumentType.NewId, interface=ZriverCommandCallbackV1),
    )
    def run_command(self, seat: WlSeat) -> Proxy[ZriverCommandCallbackV1]:
        """Run the current command

        Execute the command built up using the add_argument request for the
        given seat.

        :param seat:
        :type seat:
            :class:`~pywayland.protocol.wayland.WlSeat`
        :returns:
            :class:`~pywayland.protocol.river_control_unstable_v1.ZriverCommandCallbackV1`
            -- callback object
        """
        callback = self._marshal_constructor(2, ZriverCommandCallbackV1, seat)
        return callback


class ZriverControlV1Resource(Resource):
    interface = ZriverControlV1


class ZriverControlV1Global(Global):
    interface = ZriverControlV1


ZriverControlV1._gen_c()
ZriverControlV1.proxy_class = ZriverControlV1Proxy
ZriverControlV1.resource_class = ZriverControlV1Resource
ZriverControlV1.global_class = ZriverControlV1Global
