# This file has been autogenerated by the pywayland scanner

# Copyright 2020 The River Developers
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from __future__ import annotations

from pywayland.protocol.wayland import WlOutput, WlSeat
from pywayland.protocol_core import (Argument, ArgumentType, Global, Interface,
                                     Proxy, Resource)

from .zriver_output_status_v1 import ZriverOutputStatusV1
from .zriver_seat_status_v1 import ZriverSeatStatusV1


class ZriverStatusManagerV1(Interface):
    """Manage river status objects

    A global factory for objects that receive status information specific to
    river. It could be used to implement, for example, a status bar.
    """

    name = "zriver_status_manager_v1"
    version = 4


class ZriverStatusManagerV1Proxy(Proxy[ZriverStatusManagerV1]):
    interface = ZriverStatusManagerV1

    @ZriverStatusManagerV1.request()
    def destroy(self) -> None:
        """Destroy the river_status_manager object

        This request indicates that the client will not use the
        river_status_manager object any more. Objects that have been created
        through this instance are not affected.
        """
        self._marshal(0)
        self._destroy()

    @ZriverStatusManagerV1.request(
        Argument(ArgumentType.NewId, interface=ZriverOutputStatusV1),
        Argument(ArgumentType.Object, interface=WlOutput),
    )
    def get_river_output_status(self, output: WlOutput) -> Proxy[ZriverOutputStatusV1]:
        """Create an output status object

        This creates a new river_output_status object for the given
        :class:`~pywayland.protocol.wayland.WlOutput`.

        :param output:
        :type output:
            :class:`~pywayland.protocol.wayland.WlOutput`
        :returns:
            :class:`~pywayland.protocol.river_status_unstable_v1.ZriverOutputStatusV1`
        """
        id = self._marshal_constructor(1, ZriverOutputStatusV1, output)
        return id

    @ZriverStatusManagerV1.request(
        Argument(ArgumentType.NewId, interface=ZriverSeatStatusV1),
        Argument(ArgumentType.Object, interface=WlSeat),
    )
    def get_river_seat_status(self, seat: WlSeat) -> Proxy[ZriverSeatStatusV1]:
        """Create a seat status object

        This creates a new river_seat_status object for the given
        :class:`~pywayland.protocol.wayland.WlSeat`.

        :param seat:
        :type seat:
            :class:`~pywayland.protocol.wayland.WlSeat`
        :returns:
            :class:`~pywayland.protocol.river_status_unstable_v1.ZriverSeatStatusV1`
        """
        id = self._marshal_constructor(2, ZriverSeatStatusV1, seat)
        return id


class ZriverStatusManagerV1Resource(Resource):
    interface = ZriverStatusManagerV1


class ZriverStatusManagerV1Global(Global):
    interface = ZriverStatusManagerV1


ZriverStatusManagerV1._gen_c()
ZriverStatusManagerV1.proxy_class = ZriverStatusManagerV1Proxy
ZriverStatusManagerV1.resource_class = ZriverStatusManagerV1Resource
ZriverStatusManagerV1.global_class = ZriverStatusManagerV1Global
